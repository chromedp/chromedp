package indexeddb

import (
	"errors"

	"github.com/knq/chromedp/cdp/runtime"
	"github.com/mailru/easyjson"
	"github.com/mailru/easyjson/jlexer"
	"github.com/mailru/easyjson/jwriter"
)

// Code generated by chromedp-gen. DO NOT EDIT.

// DatabaseWithObjectStores database with an array of object stores.
type DatabaseWithObjectStores struct {
	Name         string         `json:"name"`         // Database name.
	Version      int64          `json:"version"`      // Database version.
	ObjectStores []*ObjectStore `json:"objectStores"` // Object stores in this database.
}

// ObjectStore object store.
type ObjectStore struct {
	Name          string              `json:"name"`          // Object store name.
	KeyPath       *KeyPath            `json:"keyPath"`       // Object store key path.
	AutoIncrement bool                `json:"autoIncrement"` // If true, object store has auto increment flag set.
	Indexes       []*ObjectStoreIndex `json:"indexes"`       // Indexes in this object store.
}

// ObjectStoreIndex object store index.
type ObjectStoreIndex struct {
	Name       string   `json:"name"`       // Index name.
	KeyPath    *KeyPath `json:"keyPath"`    // Index key path.
	Unique     bool     `json:"unique"`     // If true, index is unique.
	MultiEntry bool     `json:"multiEntry"` // If true, index allows multiple entries for a key.
}

// Key key.
type Key struct {
	Type   KeyType `json:"type"`             // Key type.
	Number float64 `json:"number,omitempty"` // Number value.
	String string  `json:"string,omitempty"` // String value.
	Date   float64 `json:"date,omitempty"`   // Date value.
	Array  []*Key  `json:"array,omitempty"`  // Array value.
}

// KeyRange key range.
type KeyRange struct {
	Lower     *Key `json:"lower,omitempty"` // Lower bound.
	Upper     *Key `json:"upper,omitempty"` // Upper bound.
	LowerOpen bool `json:"lowerOpen"`       // If true lower bound is open.
	UpperOpen bool `json:"upperOpen"`       // If true upper bound is open.
}

// DataEntry data entry.
type DataEntry struct {
	Key        *runtime.RemoteObject `json:"key"`        // Key object.
	PrimaryKey *runtime.RemoteObject `json:"primaryKey"` // Primary key object.
	Value      *runtime.RemoteObject `json:"value"`      // Value object.
}

// KeyPath key path.
type KeyPath struct {
	Type   KeyPathType `json:"type"`             // Key path type.
	String string      `json:"string,omitempty"` // String value.
	Array  []string    `json:"array,omitempty"`  // Array value.
}

// KeyType key type.
type KeyType string

// String returns the KeyType as string value.
func (t KeyType) String() string {
	return string(t)
}

// KeyType values.
const (
	KeyTypeNumber KeyType = "number"
	KeyTypeString KeyType = "string"
	KeyTypeDate   KeyType = "date"
	KeyTypeArray  KeyType = "array"
)

// MarshalEasyJSON satisfies easyjson.Marshaler.
func (t KeyType) MarshalEasyJSON(out *jwriter.Writer) {
	out.String(string(t))
}

// MarshalJSON satisfies json.Marshaler.
func (t KeyType) MarshalJSON() ([]byte, error) {
	return easyjson.Marshal(t)
}

// UnmarshalEasyJSON satisfies easyjson.Unmarshaler.
func (t *KeyType) UnmarshalEasyJSON(in *jlexer.Lexer) {
	switch KeyType(in.String()) {
	case KeyTypeNumber:
		*t = KeyTypeNumber
	case KeyTypeString:
		*t = KeyTypeString
	case KeyTypeDate:
		*t = KeyTypeDate
	case KeyTypeArray:
		*t = KeyTypeArray

	default:
		in.AddError(errors.New("unknown KeyType value"))
	}
}

// UnmarshalJSON satisfies json.Unmarshaler.
func (t *KeyType) UnmarshalJSON(buf []byte) error {
	return easyjson.Unmarshal(buf, t)
}

// KeyPathType key path type.
type KeyPathType string

// String returns the KeyPathType as string value.
func (t KeyPathType) String() string {
	return string(t)
}

// KeyPathType values.
const (
	KeyPathTypeNull   KeyPathType = "null"
	KeyPathTypeString KeyPathType = "string"
	KeyPathTypeArray  KeyPathType = "array"
)

// MarshalEasyJSON satisfies easyjson.Marshaler.
func (t KeyPathType) MarshalEasyJSON(out *jwriter.Writer) {
	out.String(string(t))
}

// MarshalJSON satisfies json.Marshaler.
func (t KeyPathType) MarshalJSON() ([]byte, error) {
	return easyjson.Marshal(t)
}

// UnmarshalEasyJSON satisfies easyjson.Unmarshaler.
func (t *KeyPathType) UnmarshalEasyJSON(in *jlexer.Lexer) {
	switch KeyPathType(in.String()) {
	case KeyPathTypeNull:
		*t = KeyPathTypeNull
	case KeyPathTypeString:
		*t = KeyPathTypeString
	case KeyPathTypeArray:
		*t = KeyPathTypeArray

	default:
		in.AddError(errors.New("unknown KeyPathType value"))
	}
}

// UnmarshalJSON satisfies json.Unmarshaler.
func (t *KeyPathType) UnmarshalJSON(buf []byte) error {
	return easyjson.Unmarshal(buf, t)
}
