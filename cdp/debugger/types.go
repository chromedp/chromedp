package debugger

import (
	"errors"

	"github.com/knq/chromedp/cdp/runtime"
	"github.com/mailru/easyjson"
	"github.com/mailru/easyjson/jlexer"
	"github.com/mailru/easyjson/jwriter"
)

// AUTOGENERATED. DO NOT EDIT.

// BreakpointID breakpoint identifier.
type BreakpointID string

// String returns the BreakpointID as string value.
func (t BreakpointID) String() string {
	return string(t)
}

// CallFrameID call frame identifier.
type CallFrameID string

// String returns the CallFrameID as string value.
func (t CallFrameID) String() string {
	return string(t)
}

// Location location in the source code.
type Location struct {
	ScriptID     runtime.ScriptID `json:"scriptId,omitempty"`     // Script identifier as reported in the Debugger.scriptParsed.
	LineNumber   int64            `json:"lineNumber,omitempty"`   // Line number in the script (0-based).
	ColumnNumber int64            `json:"columnNumber,omitempty"` // Column number in the script (0-based).
}

// ScriptPosition location in the source code.
type ScriptPosition struct {
	LineNumber   int64 `json:"lineNumber,omitempty"`
	ColumnNumber int64 `json:"columnNumber,omitempty"`
}

// CallFrame javaScript call frame. Array of call frames form the call stack.
type CallFrame struct {
	CallFrameID      CallFrameID           `json:"callFrameId,omitempty"`      // Call frame identifier. This identifier is only valid while the virtual machine is paused.
	FunctionName     string                `json:"functionName,omitempty"`     // Name of the JavaScript function called on this call frame.
	FunctionLocation *Location             `json:"functionLocation,omitempty"` // Location in the source code.
	Location         *Location             `json:"location,omitempty"`         // Location in the source code.
	ScopeChain       []*Scope              `json:"scopeChain,omitempty"`       // Scope chain for this call frame.
	This             *runtime.RemoteObject `json:"this,omitempty"`             // this object for this call frame.
	ReturnValue      *runtime.RemoteObject `json:"returnValue,omitempty"`      // The value being returned, if the function is at return point.
}

// Scope scope description.
type Scope struct {
	Type          ScopeType             `json:"type,omitempty"`   // Scope type.
	Object        *runtime.RemoteObject `json:"object,omitempty"` // Object representing the scope. For global and with scopes it represents the actual object; for the rest of the scopes, it is artificial transient object enumerating scope variables as its properties.
	Name          string                `json:"name,omitempty"`
	StartLocation *Location             `json:"startLocation,omitempty"` // Location in the source code where scope starts
	EndLocation   *Location             `json:"endLocation,omitempty"`   // Location in the source code where scope ends
}

// SearchMatch search match for resource.
type SearchMatch struct {
	LineNumber  float64 `json:"lineNumber,omitempty"`  // Line number in resource content.
	LineContent string  `json:"lineContent,omitempty"` // Line with match content.
}

// ScopeType scope type.
type ScopeType string

// String returns the ScopeType as string value.
func (t ScopeType) String() string {
	return string(t)
}

// ScopeType values.
const (
	ScopeTypeGlobal  ScopeType = "global"
	ScopeTypeLocal   ScopeType = "local"
	ScopeTypeWith    ScopeType = "with"
	ScopeTypeClosure ScopeType = "closure"
	ScopeTypeCatch   ScopeType = "catch"
	ScopeTypeBlock   ScopeType = "block"
	ScopeTypeScript  ScopeType = "script"
	ScopeTypeEval    ScopeType = "eval"
	ScopeTypeModule  ScopeType = "module"
)

// MarshalEasyJSON satisfies easyjson.Marshaler.
func (t ScopeType) MarshalEasyJSON(out *jwriter.Writer) {
	out.String(string(t))
}

// MarshalJSON satisfies json.Marshaler.
func (t ScopeType) MarshalJSON() ([]byte, error) {
	return easyjson.Marshal(t)
}

// UnmarshalEasyJSON satisfies easyjson.Unmarshaler.
func (t *ScopeType) UnmarshalEasyJSON(in *jlexer.Lexer) {
	switch ScopeType(in.String()) {
	case ScopeTypeGlobal:
		*t = ScopeTypeGlobal
	case ScopeTypeLocal:
		*t = ScopeTypeLocal
	case ScopeTypeWith:
		*t = ScopeTypeWith
	case ScopeTypeClosure:
		*t = ScopeTypeClosure
	case ScopeTypeCatch:
		*t = ScopeTypeCatch
	case ScopeTypeBlock:
		*t = ScopeTypeBlock
	case ScopeTypeScript:
		*t = ScopeTypeScript
	case ScopeTypeEval:
		*t = ScopeTypeEval
	case ScopeTypeModule:
		*t = ScopeTypeModule

	default:
		in.AddError(errors.New("unknown ScopeType value"))
	}
}

// UnmarshalJSON satisfies json.Unmarshaler.
func (t *ScopeType) UnmarshalJSON(buf []byte) error {
	return easyjson.Unmarshal(buf, t)
}

// PausedReason pause reason.
type PausedReason string

// String returns the PausedReason as string value.
func (t PausedReason) String() string {
	return string(t)
}

// PausedReason values.
const (
	PausedReasonXHR              PausedReason = "XHR"
	PausedReasonDOM              PausedReason = "DOM"
	PausedReasonEventListener    PausedReason = "EventListener"
	PausedReasonException        PausedReason = "exception"
	PausedReasonAssert           PausedReason = "assert"
	PausedReasonDebugCommand     PausedReason = "debugCommand"
	PausedReasonPromiseRejection PausedReason = "promiseRejection"
	PausedReasonOOM              PausedReason = "OOM"
	PausedReasonOther            PausedReason = "other"
)

// MarshalEasyJSON satisfies easyjson.Marshaler.
func (t PausedReason) MarshalEasyJSON(out *jwriter.Writer) {
	out.String(string(t))
}

// MarshalJSON satisfies json.Marshaler.
func (t PausedReason) MarshalJSON() ([]byte, error) {
	return easyjson.Marshal(t)
}

// UnmarshalEasyJSON satisfies easyjson.Unmarshaler.
func (t *PausedReason) UnmarshalEasyJSON(in *jlexer.Lexer) {
	switch PausedReason(in.String()) {
	case PausedReasonXHR:
		*t = PausedReasonXHR
	case PausedReasonDOM:
		*t = PausedReasonDOM
	case PausedReasonEventListener:
		*t = PausedReasonEventListener
	case PausedReasonException:
		*t = PausedReasonException
	case PausedReasonAssert:
		*t = PausedReasonAssert
	case PausedReasonDebugCommand:
		*t = PausedReasonDebugCommand
	case PausedReasonPromiseRejection:
		*t = PausedReasonPromiseRejection
	case PausedReasonOOM:
		*t = PausedReasonOOM
	case PausedReasonOther:
		*t = PausedReasonOther

	default:
		in.AddError(errors.New("unknown PausedReason value"))
	}
}

// UnmarshalJSON satisfies json.Unmarshaler.
func (t *PausedReason) UnmarshalJSON(buf []byte) error {
	return easyjson.Unmarshal(buf, t)
}

// ExceptionsState pause on exceptions mode.
type ExceptionsState string

// String returns the ExceptionsState as string value.
func (t ExceptionsState) String() string {
	return string(t)
}

// ExceptionsState values.
const (
	ExceptionsStateNone     ExceptionsState = "none"
	ExceptionsStateUncaught ExceptionsState = "uncaught"
	ExceptionsStateAll      ExceptionsState = "all"
)

// MarshalEasyJSON satisfies easyjson.Marshaler.
func (t ExceptionsState) MarshalEasyJSON(out *jwriter.Writer) {
	out.String(string(t))
}

// MarshalJSON satisfies json.Marshaler.
func (t ExceptionsState) MarshalJSON() ([]byte, error) {
	return easyjson.Marshal(t)
}

// UnmarshalEasyJSON satisfies easyjson.Unmarshaler.
func (t *ExceptionsState) UnmarshalEasyJSON(in *jlexer.Lexer) {
	switch ExceptionsState(in.String()) {
	case ExceptionsStateNone:
		*t = ExceptionsStateNone
	case ExceptionsStateUncaught:
		*t = ExceptionsStateUncaught
	case ExceptionsStateAll:
		*t = ExceptionsStateAll

	default:
		in.AddError(errors.New("unknown ExceptionsState value"))
	}
}

// UnmarshalJSON satisfies json.Unmarshaler.
func (t *ExceptionsState) UnmarshalJSON(buf []byte) error {
	return easyjson.Unmarshal(buf, t)
}
