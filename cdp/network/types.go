package network

// AUTOGENERATED. DO NOT EDIT.

import (
	"errors"

	cdp "github.com/knq/chromedp/cdp"
	"github.com/knq/chromedp/cdp/page"
	"github.com/knq/chromedp/cdp/runtime"
	"github.com/knq/chromedp/cdp/security"
	"github.com/mailru/easyjson"
	"github.com/mailru/easyjson/jlexer"
	"github.com/mailru/easyjson/jwriter"
)

// RequestID unique request identifier.
type RequestID string

// String returns the RequestID as string value.
func (t RequestID) String() string {
	return string(t)
}

// InterceptionID unique intercepted request identifier.
type InterceptionID string

// String returns the InterceptionID as string value.
func (t InterceptionID) String() string {
	return string(t)
}

// ErrorReason network level fetch failure reason.
type ErrorReason string

// String returns the ErrorReason as string value.
func (t ErrorReason) String() string {
	return string(t)
}

// ErrorReason values.
const (
	ErrorReasonFailed               ErrorReason = "Failed"
	ErrorReasonAborted              ErrorReason = "Aborted"
	ErrorReasonTimedOut             ErrorReason = "TimedOut"
	ErrorReasonAccessDenied         ErrorReason = "AccessDenied"
	ErrorReasonConnectionClosed     ErrorReason = "ConnectionClosed"
	ErrorReasonConnectionReset      ErrorReason = "ConnectionReset"
	ErrorReasonConnectionRefused    ErrorReason = "ConnectionRefused"
	ErrorReasonConnectionAborted    ErrorReason = "ConnectionAborted"
	ErrorReasonConnectionFailed     ErrorReason = "ConnectionFailed"
	ErrorReasonNameNotResolved      ErrorReason = "NameNotResolved"
	ErrorReasonInternetDisconnected ErrorReason = "InternetDisconnected"
	ErrorReasonAddressUnreachable   ErrorReason = "AddressUnreachable"
)

// MarshalEasyJSON satisfies easyjson.Marshaler.
func (t ErrorReason) MarshalEasyJSON(out *jwriter.Writer) {
	out.String(string(t))
}

// MarshalJSON satisfies json.Marshaler.
func (t ErrorReason) MarshalJSON() ([]byte, error) {
	return easyjson.Marshal(t)
}

// UnmarshalEasyJSON satisfies easyjson.Unmarshaler.
func (t *ErrorReason) UnmarshalEasyJSON(in *jlexer.Lexer) {
	switch ErrorReason(in.String()) {
	case ErrorReasonFailed:
		*t = ErrorReasonFailed
	case ErrorReasonAborted:
		*t = ErrorReasonAborted
	case ErrorReasonTimedOut:
		*t = ErrorReasonTimedOut
	case ErrorReasonAccessDenied:
		*t = ErrorReasonAccessDenied
	case ErrorReasonConnectionClosed:
		*t = ErrorReasonConnectionClosed
	case ErrorReasonConnectionReset:
		*t = ErrorReasonConnectionReset
	case ErrorReasonConnectionRefused:
		*t = ErrorReasonConnectionRefused
	case ErrorReasonConnectionAborted:
		*t = ErrorReasonConnectionAborted
	case ErrorReasonConnectionFailed:
		*t = ErrorReasonConnectionFailed
	case ErrorReasonNameNotResolved:
		*t = ErrorReasonNameNotResolved
	case ErrorReasonInternetDisconnected:
		*t = ErrorReasonInternetDisconnected
	case ErrorReasonAddressUnreachable:
		*t = ErrorReasonAddressUnreachable

	default:
		in.AddError(errors.New("unknown ErrorReason value"))
	}
}

// UnmarshalJSON satisfies json.Unmarshaler.
func (t *ErrorReason) UnmarshalJSON(buf []byte) error {
	return easyjson.Unmarshal(buf, t)
}

// Headers request / response headers as keys / values of JSON object.
type Headers struct{}

// ConnectionType loading priority of a resource request.
type ConnectionType string

// String returns the ConnectionType as string value.
func (t ConnectionType) String() string {
	return string(t)
}

// ConnectionType values.
const (
	ConnectionTypeNone       ConnectionType = "none"
	ConnectionTypeCellular2g ConnectionType = "cellular2g"
	ConnectionTypeCellular3g ConnectionType = "cellular3g"
	ConnectionTypeCellular4g ConnectionType = "cellular4g"
	ConnectionTypeBluetooth  ConnectionType = "bluetooth"
	ConnectionTypeEthernet   ConnectionType = "ethernet"
	ConnectionTypeWifi       ConnectionType = "wifi"
	ConnectionTypeWimax      ConnectionType = "wimax"
	ConnectionTypeOther      ConnectionType = "other"
)

// MarshalEasyJSON satisfies easyjson.Marshaler.
func (t ConnectionType) MarshalEasyJSON(out *jwriter.Writer) {
	out.String(string(t))
}

// MarshalJSON satisfies json.Marshaler.
func (t ConnectionType) MarshalJSON() ([]byte, error) {
	return easyjson.Marshal(t)
}

// UnmarshalEasyJSON satisfies easyjson.Unmarshaler.
func (t *ConnectionType) UnmarshalEasyJSON(in *jlexer.Lexer) {
	switch ConnectionType(in.String()) {
	case ConnectionTypeNone:
		*t = ConnectionTypeNone
	case ConnectionTypeCellular2g:
		*t = ConnectionTypeCellular2g
	case ConnectionTypeCellular3g:
		*t = ConnectionTypeCellular3g
	case ConnectionTypeCellular4g:
		*t = ConnectionTypeCellular4g
	case ConnectionTypeBluetooth:
		*t = ConnectionTypeBluetooth
	case ConnectionTypeEthernet:
		*t = ConnectionTypeEthernet
	case ConnectionTypeWifi:
		*t = ConnectionTypeWifi
	case ConnectionTypeWimax:
		*t = ConnectionTypeWimax
	case ConnectionTypeOther:
		*t = ConnectionTypeOther

	default:
		in.AddError(errors.New("unknown ConnectionType value"))
	}
}

// UnmarshalJSON satisfies json.Unmarshaler.
func (t *ConnectionType) UnmarshalJSON(buf []byte) error {
	return easyjson.Unmarshal(buf, t)
}

// CookieSameSite represents the cookie's 'SameSite' status:
// https://tools.ietf.org/html/draft-west-first-party-cookies.
type CookieSameSite string

// String returns the CookieSameSite as string value.
func (t CookieSameSite) String() string {
	return string(t)
}

// CookieSameSite values.
const (
	CookieSameSiteStrict CookieSameSite = "Strict"
	CookieSameSiteLax    CookieSameSite = "Lax"
)

// MarshalEasyJSON satisfies easyjson.Marshaler.
func (t CookieSameSite) MarshalEasyJSON(out *jwriter.Writer) {
	out.String(string(t))
}

// MarshalJSON satisfies json.Marshaler.
func (t CookieSameSite) MarshalJSON() ([]byte, error) {
	return easyjson.Marshal(t)
}

// UnmarshalEasyJSON satisfies easyjson.Unmarshaler.
func (t *CookieSameSite) UnmarshalEasyJSON(in *jlexer.Lexer) {
	switch CookieSameSite(in.String()) {
	case CookieSameSiteStrict:
		*t = CookieSameSiteStrict
	case CookieSameSiteLax:
		*t = CookieSameSiteLax

	default:
		in.AddError(errors.New("unknown CookieSameSite value"))
	}
}

// UnmarshalJSON satisfies json.Unmarshaler.
func (t *CookieSameSite) UnmarshalJSON(buf []byte) error {
	return easyjson.Unmarshal(buf, t)
}

// ResourceTiming timing information for the request.
type ResourceTiming struct {
	RequestTime       float64 `json:"requestTime,omitempty"`       // Timing's requestTime is a baseline in seconds, while the other numbers are ticks in milliseconds relatively to this requestTime.
	ProxyStart        float64 `json:"proxyStart,omitempty"`        // Started resolving proxy.
	ProxyEnd          float64 `json:"proxyEnd,omitempty"`          // Finished resolving proxy.
	DNSStart          float64 `json:"dnsStart,omitempty"`          // Started DNS address resolve.
	DNSEnd            float64 `json:"dnsEnd,omitempty"`            // Finished DNS address resolve.
	ConnectStart      float64 `json:"connectStart,omitempty"`      // Started connecting to the remote host.
	ConnectEnd        float64 `json:"connectEnd,omitempty"`        // Connected to the remote host.
	SslStart          float64 `json:"sslStart,omitempty"`          // Started SSL handshake.
	SslEnd            float64 `json:"sslEnd,omitempty"`            // Finished SSL handshake.
	WorkerStart       float64 `json:"workerStart,omitempty"`       // Started running ServiceWorker.
	WorkerReady       float64 `json:"workerReady,omitempty"`       // Finished Starting ServiceWorker.
	SendStart         float64 `json:"sendStart,omitempty"`         // Started sending request.
	SendEnd           float64 `json:"sendEnd,omitempty"`           // Finished sending request.
	PushStart         float64 `json:"pushStart,omitempty"`         // Time the server started pushing request.
	PushEnd           float64 `json:"pushEnd,omitempty"`           // Time the server finished pushing request.
	ReceiveHeadersEnd float64 `json:"receiveHeadersEnd,omitempty"` // Finished receiving response headers.
}

// ResourcePriority loading priority of a resource request.
type ResourcePriority string

// String returns the ResourcePriority as string value.
func (t ResourcePriority) String() string {
	return string(t)
}

// ResourcePriority values.
const (
	ResourcePriorityVeryLow  ResourcePriority = "VeryLow"
	ResourcePriorityLow      ResourcePriority = "Low"
	ResourcePriorityMedium   ResourcePriority = "Medium"
	ResourcePriorityHigh     ResourcePriority = "High"
	ResourcePriorityVeryHigh ResourcePriority = "VeryHigh"
)

// MarshalEasyJSON satisfies easyjson.Marshaler.
func (t ResourcePriority) MarshalEasyJSON(out *jwriter.Writer) {
	out.String(string(t))
}

// MarshalJSON satisfies json.Marshaler.
func (t ResourcePriority) MarshalJSON() ([]byte, error) {
	return easyjson.Marshal(t)
}

// UnmarshalEasyJSON satisfies easyjson.Unmarshaler.
func (t *ResourcePriority) UnmarshalEasyJSON(in *jlexer.Lexer) {
	switch ResourcePriority(in.String()) {
	case ResourcePriorityVeryLow:
		*t = ResourcePriorityVeryLow
	case ResourcePriorityLow:
		*t = ResourcePriorityLow
	case ResourcePriorityMedium:
		*t = ResourcePriorityMedium
	case ResourcePriorityHigh:
		*t = ResourcePriorityHigh
	case ResourcePriorityVeryHigh:
		*t = ResourcePriorityVeryHigh

	default:
		in.AddError(errors.New("unknown ResourcePriority value"))
	}
}

// UnmarshalJSON satisfies json.Unmarshaler.
func (t *ResourcePriority) UnmarshalJSON(buf []byte) error {
	return easyjson.Unmarshal(buf, t)
}

// Request hTTP request data.
type Request struct {
	URL              string           `json:"url,omitempty"`              // Request URL.
	Method           string           `json:"method,omitempty"`           // HTTP request method.
	Headers          *Headers         `json:"headers,omitempty"`          // HTTP request headers.
	PostData         string           `json:"postData,omitempty"`         // HTTP POST request data.
	MixedContentType MixedContentType `json:"mixedContentType,omitempty"` // The mixed content status of the request, as defined in http://www.w3.org/TR/mixed-content/
	InitialPriority  ResourcePriority `json:"initialPriority,omitempty"`  // Priority of the resource request at the time request is sent.
	ReferrerPolicy   ReferrerPolicy   `json:"referrerPolicy,omitempty"`   // The referrer policy of the request, as defined in https://www.w3.org/TR/referrer-policy/
	IsLinkPreload    bool             `json:"isLinkPreload,omitempty"`    // Whether is loaded via link preload.
}

// SignedCertificateTimestamp details of a signed certificate timestamp
// (SCT).
type SignedCertificateTimestamp struct {
	Status             string        `json:"status,omitempty"`             // Validation status.
	Origin             string        `json:"origin,omitempty"`             // Origin.
	LogDescription     string        `json:"logDescription,omitempty"`     // Log name / description.
	LogID              string        `json:"logId,omitempty"`              // Log ID.
	Timestamp          cdp.Timestamp `json:"timestamp,omitempty"`          // Issuance date.
	HashAlgorithm      string        `json:"hashAlgorithm,omitempty"`      // Hash algorithm.
	SignatureAlgorithm string        `json:"signatureAlgorithm,omitempty"` // Signature algorithm.
	SignatureData      string        `json:"signatureData,omitempty"`      // Signature data.
}

// SecurityDetails security details about a request.
type SecurityDetails struct {
	Protocol                       string                        `json:"protocol,omitempty"`                       // Protocol name (e.g. "TLS 1.2" or "QUIC").
	KeyExchange                    string                        `json:"keyExchange,omitempty"`                    // Key Exchange used by the connection, or the empty string if not applicable.
	KeyExchangeGroup               string                        `json:"keyExchangeGroup,omitempty"`               // (EC)DH group used by the connection, if applicable.
	Cipher                         string                        `json:"cipher,omitempty"`                         // Cipher name.
	Mac                            string                        `json:"mac,omitempty"`                            // TLS MAC. Note that AEAD ciphers do not have separate MACs.
	CertificateID                  security.CertificateID        `json:"certificateId,omitempty"`                  // Certificate ID value.
	SubjectName                    string                        `json:"subjectName,omitempty"`                    // Certificate subject name.
	SanList                        []string                      `json:"sanList,omitempty"`                        // Subject Alternative Name (SAN) DNS names and IP addresses.
	Issuer                         string                        `json:"issuer,omitempty"`                         // Name of the issuing CA.
	ValidFrom                      cdp.Timestamp                 `json:"validFrom,omitempty"`                      // Certificate valid from date.
	ValidTo                        cdp.Timestamp                 `json:"validTo,omitempty"`                        // Certificate valid to (expiration) date
	SignedCertificateTimestampList []*SignedCertificateTimestamp `json:"signedCertificateTimestampList,omitempty"` // List of signed certificate timestamps (SCTs).
}

// BlockedReason the reason why request was blocked.
type BlockedReason string

// String returns the BlockedReason as string value.
func (t BlockedReason) String() string {
	return string(t)
}

// BlockedReason values.
const (
	BlockedReasonCsp               BlockedReason = "csp"
	BlockedReasonMixedContent      BlockedReason = "mixed-content"
	BlockedReasonOrigin            BlockedReason = "origin"
	BlockedReasonInspector         BlockedReason = "inspector"
	BlockedReasonSubresourceFilter BlockedReason = "subresource-filter"
	BlockedReasonOther             BlockedReason = "other"
)

// MarshalEasyJSON satisfies easyjson.Marshaler.
func (t BlockedReason) MarshalEasyJSON(out *jwriter.Writer) {
	out.String(string(t))
}

// MarshalJSON satisfies json.Marshaler.
func (t BlockedReason) MarshalJSON() ([]byte, error) {
	return easyjson.Marshal(t)
}

// UnmarshalEasyJSON satisfies easyjson.Unmarshaler.
func (t *BlockedReason) UnmarshalEasyJSON(in *jlexer.Lexer) {
	switch BlockedReason(in.String()) {
	case BlockedReasonCsp:
		*t = BlockedReasonCsp
	case BlockedReasonMixedContent:
		*t = BlockedReasonMixedContent
	case BlockedReasonOrigin:
		*t = BlockedReasonOrigin
	case BlockedReasonInspector:
		*t = BlockedReasonInspector
	case BlockedReasonSubresourceFilter:
		*t = BlockedReasonSubresourceFilter
	case BlockedReasonOther:
		*t = BlockedReasonOther

	default:
		in.AddError(errors.New("unknown BlockedReason value"))
	}
}

// UnmarshalJSON satisfies json.Unmarshaler.
func (t *BlockedReason) UnmarshalJSON(buf []byte) error {
	return easyjson.Unmarshal(buf, t)
}

// Response hTTP response data.
type Response struct {
	URL                string           `json:"url,omitempty"`                // Response URL. This URL can be different from CachedResource.url in case of redirect.
	Status             float64          `json:"status,omitempty"`             // HTTP response status code.
	StatusText         string           `json:"statusText,omitempty"`         // HTTP response status text.
	Headers            *Headers         `json:"headers,omitempty"`            // HTTP response headers.
	HeadersText        string           `json:"headersText,omitempty"`        // HTTP response headers text.
	MimeType           string           `json:"mimeType,omitempty"`           // Resource mimeType as determined by the browser.
	RequestHeaders     *Headers         `json:"requestHeaders,omitempty"`     // Refined HTTP request headers that were actually transmitted over the network.
	RequestHeadersText string           `json:"requestHeadersText,omitempty"` // HTTP request headers text.
	ConnectionReused   bool             `json:"connectionReused,omitempty"`   // Specifies whether physical connection was actually reused for this request.
	ConnectionID       float64          `json:"connectionId,omitempty"`       // Physical connection id that was actually used for this request.
	RemoteIPAddress    string           `json:"remoteIPAddress,omitempty"`    // Remote IP address.
	RemotePort         int64            `json:"remotePort,omitempty"`         // Remote port.
	FromDiskCache      bool             `json:"fromDiskCache,omitempty"`      // Specifies that the request was served from the disk cache.
	FromServiceWorker  bool             `json:"fromServiceWorker,omitempty"`  // Specifies that the request was served from the ServiceWorker.
	EncodedDataLength  float64          `json:"encodedDataLength,omitempty"`  // Total number of bytes received for this request so far.
	Timing             *ResourceTiming  `json:"timing,omitempty"`             // Timing information for the given request.
	Protocol           string           `json:"protocol,omitempty"`           // Protocol used to fetch this request.
	SecurityState      security.State   `json:"securityState,omitempty"`      // Security state of the request resource.
	SecurityDetails    *SecurityDetails `json:"securityDetails,omitempty"`    // Security details for the request.
}

// WebSocketRequest webSocket request data.
type WebSocketRequest struct {
	Headers *Headers `json:"headers,omitempty"` // HTTP request headers.
}

// WebSocketResponse webSocket response data.
type WebSocketResponse struct {
	Status             float64  `json:"status,omitempty"`             // HTTP response status code.
	StatusText         string   `json:"statusText,omitempty"`         // HTTP response status text.
	Headers            *Headers `json:"headers,omitempty"`            // HTTP response headers.
	HeadersText        string   `json:"headersText,omitempty"`        // HTTP response headers text.
	RequestHeaders     *Headers `json:"requestHeaders,omitempty"`     // HTTP request headers.
	RequestHeadersText string   `json:"requestHeadersText,omitempty"` // HTTP request headers text.
}

// WebSocketFrame webSocket frame data.
type WebSocketFrame struct {
	Opcode      float64 `json:"opcode,omitempty"`      // WebSocket frame opcode.
	Mask        bool    `json:"mask,omitempty"`        // WebSocke frame mask.
	PayloadData string  `json:"payloadData,omitempty"` // WebSocke frame payload data.
}

// CachedResource information about the cached resource.
type CachedResource struct {
	URL      string            `json:"url,omitempty"`      // Resource URL. This is the url of the original network request.
	Type     page.ResourceType `json:"type,omitempty"`     // Type of this resource.
	Response *Response         `json:"response,omitempty"` // Cached response data.
	BodySize float64           `json:"bodySize,omitempty"` // Cached response body size.
}

// Initiator information about the request initiator.
type Initiator struct {
	Type       InitiatorType       `json:"type,omitempty"`       // Type of this initiator.
	Stack      *runtime.StackTrace `json:"stack,omitempty"`      // Initiator JavaScript stack trace, set for Script only.
	URL        string              `json:"url,omitempty"`        // Initiator URL, set for Parser type only.
	LineNumber float64             `json:"lineNumber,omitempty"` // Initiator line number, set for Parser type only (0-based).
}

// Cookie cookie object.
type Cookie struct {
	Name     string         `json:"name,omitempty"`     // Cookie name.
	Value    string         `json:"value,omitempty"`    // Cookie value.
	Domain   string         `json:"domain,omitempty"`   // Cookie domain.
	Path     string         `json:"path,omitempty"`     // Cookie path.
	Expires  float64        `json:"expires,omitempty"`  // Cookie expiration date as the number of seconds since the UNIX epoch.
	Size     int64          `json:"size,omitempty"`     // Cookie size.
	HTTPOnly bool           `json:"httpOnly,omitempty"` // True if cookie is http-only.
	Secure   bool           `json:"secure,omitempty"`   // True if cookie is secure.
	Session  bool           `json:"session,omitempty"`  // True in case of session cookie.
	SameSite CookieSameSite `json:"sameSite,omitempty"` // Cookie SameSite type.
}

// MixedContentType the mixed content status of the request, as defined in
// http://www.w3.org/TR/mixed-content/.
type MixedContentType string

// String returns the MixedContentType as string value.
func (t MixedContentType) String() string {
	return string(t)
}

// MixedContentType values.
const (
	MixedContentTypeBlockable           MixedContentType = "blockable"
	MixedContentTypeOptionallyBlockable MixedContentType = "optionally-blockable"
	MixedContentTypeNone                MixedContentType = "none"
)

// MarshalEasyJSON satisfies easyjson.Marshaler.
func (t MixedContentType) MarshalEasyJSON(out *jwriter.Writer) {
	out.String(string(t))
}

// MarshalJSON satisfies json.Marshaler.
func (t MixedContentType) MarshalJSON() ([]byte, error) {
	return easyjson.Marshal(t)
}

// UnmarshalEasyJSON satisfies easyjson.Unmarshaler.
func (t *MixedContentType) UnmarshalEasyJSON(in *jlexer.Lexer) {
	switch MixedContentType(in.String()) {
	case MixedContentTypeBlockable:
		*t = MixedContentTypeBlockable
	case MixedContentTypeOptionallyBlockable:
		*t = MixedContentTypeOptionallyBlockable
	case MixedContentTypeNone:
		*t = MixedContentTypeNone

	default:
		in.AddError(errors.New("unknown MixedContentType value"))
	}
}

// UnmarshalJSON satisfies json.Unmarshaler.
func (t *MixedContentType) UnmarshalJSON(buf []byte) error {
	return easyjson.Unmarshal(buf, t)
}

// ReferrerPolicy the referrer policy of the request, as defined in
// https://www.w3.org/TR/referrer-policy/.
type ReferrerPolicy string

// String returns the ReferrerPolicy as string value.
func (t ReferrerPolicy) String() string {
	return string(t)
}

// ReferrerPolicy values.
const (
	ReferrerPolicyUnsafeURL                                    ReferrerPolicy = "unsafe-url"
	ReferrerPolicyNoReferrerWhenDowngrade                      ReferrerPolicy = "no-referrer-when-downgrade"
	ReferrerPolicyNoReferrer                                   ReferrerPolicy = "no-referrer"
	ReferrerPolicyOrigin                                       ReferrerPolicy = "origin"
	ReferrerPolicyOriginWhenCrossOrigin                        ReferrerPolicy = "origin-when-cross-origin"
	ReferrerPolicyNoReferrerWhenDowngradeOriginWhenCrossOrigin ReferrerPolicy = "no-referrer-when-downgrade-origin-when-cross-origin"
)

// MarshalEasyJSON satisfies easyjson.Marshaler.
func (t ReferrerPolicy) MarshalEasyJSON(out *jwriter.Writer) {
	out.String(string(t))
}

// MarshalJSON satisfies json.Marshaler.
func (t ReferrerPolicy) MarshalJSON() ([]byte, error) {
	return easyjson.Marshal(t)
}

// UnmarshalEasyJSON satisfies easyjson.Unmarshaler.
func (t *ReferrerPolicy) UnmarshalEasyJSON(in *jlexer.Lexer) {
	switch ReferrerPolicy(in.String()) {
	case ReferrerPolicyUnsafeURL:
		*t = ReferrerPolicyUnsafeURL
	case ReferrerPolicyNoReferrerWhenDowngrade:
		*t = ReferrerPolicyNoReferrerWhenDowngrade
	case ReferrerPolicyNoReferrer:
		*t = ReferrerPolicyNoReferrer
	case ReferrerPolicyOrigin:
		*t = ReferrerPolicyOrigin
	case ReferrerPolicyOriginWhenCrossOrigin:
		*t = ReferrerPolicyOriginWhenCrossOrigin
	case ReferrerPolicyNoReferrerWhenDowngradeOriginWhenCrossOrigin:
		*t = ReferrerPolicyNoReferrerWhenDowngradeOriginWhenCrossOrigin

	default:
		in.AddError(errors.New("unknown ReferrerPolicy value"))
	}
}

// UnmarshalJSON satisfies json.Unmarshaler.
func (t *ReferrerPolicy) UnmarshalJSON(buf []byte) error {
	return easyjson.Unmarshal(buf, t)
}

// InitiatorType type of this initiator.
type InitiatorType string

// String returns the InitiatorType as string value.
func (t InitiatorType) String() string {
	return string(t)
}

// InitiatorType values.
const (
	InitiatorTypeParser  InitiatorType = "parser"
	InitiatorTypeScript  InitiatorType = "script"
	InitiatorTypePreload InitiatorType = "preload"
	InitiatorTypeOther   InitiatorType = "other"
)

// MarshalEasyJSON satisfies easyjson.Marshaler.
func (t InitiatorType) MarshalEasyJSON(out *jwriter.Writer) {
	out.String(string(t))
}

// MarshalJSON satisfies json.Marshaler.
func (t InitiatorType) MarshalJSON() ([]byte, error) {
	return easyjson.Marshal(t)
}

// UnmarshalEasyJSON satisfies easyjson.Unmarshaler.
func (t *InitiatorType) UnmarshalEasyJSON(in *jlexer.Lexer) {
	switch InitiatorType(in.String()) {
	case InitiatorTypeParser:
		*t = InitiatorTypeParser
	case InitiatorTypeScript:
		*t = InitiatorTypeScript
	case InitiatorTypePreload:
		*t = InitiatorTypePreload
	case InitiatorTypeOther:
		*t = InitiatorTypeOther

	default:
		in.AddError(errors.New("unknown InitiatorType value"))
	}
}

// UnmarshalJSON satisfies json.Unmarshaler.
func (t *InitiatorType) UnmarshalJSON(buf []byte) error {
	return easyjson.Unmarshal(buf, t)
}
