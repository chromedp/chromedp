// +build ignore

package main

import (
	"bytes"
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"os/exec"
	"regexp"
	"strings"
)

const (
	deviceDescriptorsURL = "https://raw.githubusercontent.com/GoogleChrome/puppeteer/master/lib/DeviceDescriptors.js"
)

var (
	flagOut = flag.String("out", "", "out")
)

func main() {
	flag.Parse()
	if err := run(); err != nil {
		log.Fatal(err)
	}
}

type deviceDescriptor struct {
	Name      string `json:"name"`
	UserAgent string `json:"userAgent"`
	Viewport  struct {
		Width             int64   `json:"width"`
		Height            int64   `json:"height"`
		DeviceScaleFactor float64 `json:"deviceScaleFactor"`
		IsMobile          bool    `json:"isMobile"`
		HasTouch          bool    `json:"hasTouch"`
		IsLandscape       bool    `json:"isLandscape"`
	}
}

var cleanRE = regexp.MustCompile(`[^a-zA-Z0-9_]`)

// run runs the program.
func run() error {
	if *flagOut == "" {
		*flagOut = "params.go"
	}

	var descriptors []deviceDescriptor
	if err := get(&descriptors); err != nil {
		return err
	}

	var cstr, dstr string
	for i, d := range descriptors {
		name := cleanRE.ReplaceAllString(d.Name, "")
		name = strings.ToUpper(name[0:1]) + name[1:]
		cstr += fmt.Sprintf("\n\t// %s is the %q device.\n", name, d.Name)
		if i == 0 {
			cstr += fmt.Sprintf("\t%s Device = iota\n", name)
		} else {
			cstr += fmt.Sprintf("\t%s\n", name)
		}
		dstr += fmt.Sprintf("\n{%q, %q, %d, %d, %f, %t, %t, %t},",
			d.Name, d.UserAgent,
			d.Viewport.Width, d.Viewport.Height, d.Viewport.DeviceScaleFactor,
			d.Viewport.IsLandscape, d.Viewport.IsMobile, d.Viewport.HasTouch,
		)
	}

	content := fmt.Sprintf(tpl, deviceDescriptorsURL, cstr, dstr)
	if err := ioutil.WriteFile(*flagOut, []byte(content), 0644); err != nil {
		return err
	}

	return exec.Command("gofmt", "-w", "-s", *flagOut).Run()
}

var (
	startRE = regexp.MustCompile(`(?m)^module\.exports\s*=\s*\[`)
	endRE   = regexp.MustCompile(`(?m)^\];$`)
)

// get retrieves and decodes the device descriptors.
func get(v interface{}) error {
	req, err := http.NewRequest("GET", deviceDescriptorsURL, nil)
	if err != nil {
		return err
	}

	// retrieve
	cl := &http.Client{}
	res, err := cl.Do(req)
	if err != nil {
		return err
	}
	defer res.Body.Close()
	if res.StatusCode != 200 {
		return fmt.Errorf("got status code %d", res.StatusCode)
	}

	buf, err := ioutil.ReadAll(res.Body)
	if err != nil {
		return err
	}

	start := startRE.FindIndex(buf)
	if start == nil {
		return errors.New("could not find start")
	}
	buf = buf[start[1]-1:]

	end := endRE.FindIndex(buf)
	if end == nil {
		return errors.New("could not find end")
	}
	buf = buf[:end[1]-1]
	buf = bytes.Replace(buf, []byte("'"), []byte(`"`), -1)
	return json.Unmarshal(buf, v)
}

const (
	tpl = `package device

// Generated by gen.go. DO NOT EDIT.

// See: %s

// Devices.
const (%s
)

// devices is the list of devices.
var devices = [...]device{%s
}
`
)
